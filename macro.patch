diff --git a/tests/all.py b/tests/all.py
index 395f964..5f54dfe 100644
--- a/tests/all.py
+++ b/tests/all.py
@@ -4661,6 +4661,11 @@ with profile.group_manager(
         grouptools.join('spec', 'arb_vertex_attrib_64bit')) as g:
     g(['arb_vertex_attrib_64bit-double_attribs'], 'double_attribs')
     g(['arb_vertex_attrib_64bit-check-explicit-location'], 'check-explicit-location')
+    g(['arb_vertex_attrib_64bit-max-vertex-attrib'], 'max-vertex-attrib')
+    g(['arb_vertex_attrib_64bit-getactiveattrib'], 'getactiveattrib')
+    for test_type in ('shader', 'api'):
+        g(['arb_vertex_attrib_64bit-overlapping-locations', test_type],
+          run_concurrent=False)
 
 with profile.group_manager(
         PiglitGLTest,
diff --git a/tests/spec/arb_vertex_attrib_64bit/execution/CMakeLists.gl.txt b/tests/spec/arb_vertex_attrib_64bit/execution/CMakeLists.gl.txt
index 3c9a980..00923a2 100644
--- a/tests/spec/arb_vertex_attrib_64bit/execution/CMakeLists.gl.txt
+++ b/tests/spec/arb_vertex_attrib_64bit/execution/CMakeLists.gl.txt
@@ -10,3 +10,7 @@ link_libraries (
 
 piglit_add_executable (arb_vertex_attrib_64bit-double_attribs double_attribs.c)
 piglit_add_executable (arb_vertex_attrib_64bit-check-explicit-location check-explicit-location.c)
+piglit_add_executable (arb_vertex_attrib_64bit-max-vertex-attrib max-vertex-attrib.c)
+piglit_add_executable (arb_vertex_attrib_64bit-zero-vertex-attrib zero-vertex-attrib.c)
+piglit_add_executable (arb_vertex_attrib_64bit-getactiveattrib  getactiveattrib.c)
+piglit_add_executable (arb_vertex_attrib_64bit-overlapping-locations overlapping-locations.c)
diff --git a/tests/spec/arb_vertex_attrib_64bit/execution/getactiveattrib.c b/tests/spec/arb_vertex_attrib_64bit/execution/getactiveattrib.c
new file mode 100644
index 0000000..dbe47da
--- /dev/null
+++ b/tests/spec/arb_vertex_attrib_64bit/execution/getactiveattrib.c
@@ -0,0 +1,351 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * \file getactiveattrib.c
+ * Verify that glGetActiveAttrib and GL_ACTIVE_ATTRIBUTES return the expected
+ * values for the new tokens defined at ARB_vertex_attrib_64bit specification.
+ *
+ * This is based on tests/general/getactiveattrib.c
+ */
+
+#include "piglit-util-gl.h"
+
+PIGLIT_GL_TEST_CONFIG_BEGIN
+
+        config.supports_gl_core_version = 32;
+
+config.window_visual = PIGLIT_GL_VISUAL_RGB | PIGLIT_GL_VISUAL_DOUBLE;
+
+PIGLIT_GL_TEST_CONFIG_END
+
+/* must_be_active and size, included on the original general
+ * getactiveattrib.c is not included here as it is not needed.*/
+struct attribute {
+        /** Name of the attribute. */
+        const char *name;
+
+        /** Expected GLSL type of the attribute. */
+        GLenum type;
+};
+
+struct test {
+        const char *code;
+
+        /**
+         * List of attributes to be checked
+         *
+         * \note
+         * The list is terminated by an attribute with a \c NULL \c name
+         * pointer.
+         */
+        struct attribute attributes[16];
+};
+
+static const struct test vertex_attrib_64bit_tests[] = {
+        /* Try all the possible types for vertex shader inputs added
+         * at the spec. They could be added as 13 attributes on the
+         * same vertex shader, but we would need to get them all
+         * active. It is easier to read this way.
+         */
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in double _double;\n"
+                "void main() { gl_Position = vec4(float(_double)); }\n",
+                {
+                        { "_double",    GL_DOUBLE },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dvec2 _dvec2;\n"
+                "void main() { gl_Position = vec4(float(_dvec2.x)); }\n",
+                {
+                        { "_dvec2",    GL_DOUBLE_VEC2 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dvec3 _dvec3;\n"
+                "void main() { gl_Position = vec4(float(_dvec3.x)); }\n",
+                {
+                        { "_dvec3",    GL_DOUBLE_VEC3 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dvec4 _dvec4;\n"
+                "void main() { gl_Position = vec4(float(_dvec4.x)); }\n",
+                {
+                        { "_dvec4",    GL_DOUBLE_VEC4 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat2 _dmat2;\n"
+                "void main() { gl_Position = vec4(float(_dmat2[0][0])); }\n",
+                {
+                        { "_dmat2",    GL_DOUBLE_MAT2 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat3 _dmat3;\n"
+                "void main() { gl_Position = vec4(float(_dmat3[0][0])); }\n",
+                {
+                        { "_dmat3",    GL_DOUBLE_MAT3 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat4 _dmat4;\n"
+                "void main() { gl_Position = vec4(float(_dmat4[0][0])); }\n",
+                {
+                        { "_dmat4",    GL_DOUBLE_MAT4 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat2x3 _dmat2x3;\n"
+                "void main() { gl_Position = vec4(float(_dmat2x3[0][0])); }\n",
+                {
+                        { "_dmat2x3",   GL_DOUBLE_MAT2x3 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat2x4 _dmat2x4;\n"
+                "void main() { gl_Position = vec4(float(_dmat2x4[0][0])); }\n",
+                {
+                        { "_dmat2x4",    GL_DOUBLE_MAT2x4 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat3x2 _dmat3x2;\n"
+                "void main() { gl_Position = vec4(float(_dmat3x2[0][0])); }\n",
+                {
+                        { "_dmat3x2",    GL_DOUBLE_MAT3x2 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat3x4 _dmat3x4;\n"
+                "void main() { gl_Position = vec4(float(_dmat3x4[0][0])); }\n",
+                {
+                        { "_dmat3x4",    GL_DOUBLE_MAT3x4 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat4x2 _dmat4x2;\n"
+                "void main() { gl_Position = vec4(float(_dmat4x2[0][0])); }\n",
+                {
+                        { "_dmat4x2",    GL_DOUBLE_MAT4x2 },
+                        { NULL, }
+                }
+        },
+        {
+                "#version 330\n"
+                "#extension GL_ARB_vertex_attrib_64bit: require\n"
+                "#extension GL_ARB_gpu_shader_fp64: require\n"
+                "in dmat4x3 _dmat4x3;\n"
+                "void main() { gl_Position = vec4(float(_dmat4x3[0][0])); }\n",
+                {
+                        { "_dmat4x3",    GL_DOUBLE_MAT4x3 },
+                        { NULL, }
+                }
+        },
+};
+
+enum piglit_result
+piglit_display(void)
+{
+        return PIGLIT_FAIL;
+}
+
+int
+find_attrib(const struct attribute *attribs, const char *name)
+{
+        unsigned i;
+
+        for (i = 0; attribs[i].name != NULL; i++) {
+                if (strcmp(attribs[i].name, name) == 0)
+                        return (int) i;
+        }
+
+        return -1;
+}
+
+#define DUMP_SHADER(code)                                                \
+        do {                                                                \
+                if (!shader_dumped) {                                        \
+                        fprintf(stderr, "\nFailing shader:\n%s\n\n",        \
+                                code);                                        \
+                        shader_dumped = true;                                \
+                }                                                        \
+        } while (false)
+
+bool
+do_test(const struct test *tests, unsigned num_tests)
+{
+        bool pass = true;
+        unsigned i;
+
+        for (i = 0; i < num_tests; i++) {
+                GLint vert =
+                        piglit_compile_shader_text(GL_VERTEX_SHADER,
+                                                   tests[i].code);
+                GLint prog = piglit_link_simple_program(vert, 0);
+                GLint num_attr;
+                unsigned visited_count[64];
+                unsigned j;
+                bool shader_dumped = false;
+
+                memset(visited_count, 0, sizeof(visited_count));
+
+                /* From page 93 (page 109 of the PDF) says:
+                 *
+                 *     "An attribute variable (either conventional or generic)
+                 *     is considered active if it is determined by the
+                 *     compiler and linker that the attribute may be accessed
+                 *     when the shader is executed. Attribute variables that
+                 *     are declared in a vertex shader but never used will not
+                 *     count against the limit. In cases where the compiler
+                 *     and linker cannot make a conclusive determination, an
+                 *     attribute will be considered active."
+                 *
+                 * Compare the set of active attributes against the list of
+                 * expected active attributes.
+                 */
+                glGetProgramiv(prog, GL_ACTIVE_ATTRIBUTES, &num_attr);
+
+                for (j = 0; j < num_attr; j++) {
+                        const struct attribute *attr;
+                        char name_buf[256];
+                        int attr_idx;
+                        GLsizei name_len;
+                        GLint size;
+                        GLenum type;
+
+                        glGetActiveAttrib(prog, j,
+                                          sizeof(name_buf),
+                                          &name_len,
+                                          &size,
+                                          &type,
+                                          name_buf);
+                        attr_idx = find_attrib(tests[i].attributes, name_buf);
+
+                        /* If the named attribute is not in the list for the
+                         * test, then it must not be active.
+                         */
+                        if (attr_idx < 0) {
+                                DUMP_SHADER(tests[i].code);
+                                fprintf(stderr,
+                                        "Attribute `%s' should not be active "
+                                        "but is.\n", name_buf);
+                                pass = false;
+                                continue;
+                        }
+
+                        attr = &tests[i].attributes[attr_idx];
+                        if (visited_count[attr_idx] != 0) {
+                                DUMP_SHADER(tests[i].code);
+                                fprintf(stderr,
+                                        "Attribute `%s' listed multiple times "
+                                        "in active list.\n", name_buf);
+                                pass = false;
+                        } else if (attr->type != type) {
+                                DUMP_SHADER(tests[i].code);
+                                fprintf(stderr,
+                                        "Attribute `%s' should have type "
+                                        "%s, but had type %s.\n",
+                                        name_buf, piglit_get_gl_enum_name(attr->type),
+                                        piglit_get_gl_enum_name(type));
+                                pass = false;
+                        }
+
+                        visited_count[attr_idx]++;
+                }
+
+                for (j = 0; tests[i].attributes[j].name != NULL; j++) {
+                        if (visited_count[j] == 0) {
+                          DUMP_SHADER(tests[i].code);
+                          fprintf(stderr,
+                                  "Attribute `%s' should have been "
+                                  "active but wasn't.\n",
+                                  tests[i].attributes[j].name);
+                          pass = false;
+                        }
+                }
+        }
+
+        return pass;
+}
+
+void piglit_init(int argc, char **argv)
+{
+        bool pass = true;
+
+        piglit_require_extension("GL_ARB_vertex_attrib_64bit");
+
+        pass = do_test(vertex_attrib_64bit_tests,
+                       ARRAY_SIZE(vertex_attrib_64bit_tests));
+
+        piglit_report_result(pass ? PIGLIT_PASS : PIGLIT_FAIL);
+}
diff --git a/tests/spec/arb_vertex_attrib_64bit/execution/max-vertex-attrib.c b/tests/spec/arb_vertex_attrib_64bit/execution/max-vertex-attrib.c
new file mode 100644
index 0000000..ae9678a
--- /dev/null
+++ b/tests/spec/arb_vertex_attrib_64bit/execution/max-vertex-attrib.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+/**
+ * \file max-vertex-attrib.c
+ *
+ * Test setting vertex attrib value of GL_MAX_VERTEX_ATTRIBS attrib
+ * for the New Procedures and Functions defined by the extension. Note
+ * that this test is based on glsl-max-vertex-attrib.c, and that that
+ * one are already testing the already existing vertex attrib methods.
+ *
+ * Queries the value for GL_MAX_VERTEX_ATTRIBS and uses that as index
+ * to set a value. GL specification states that GL_INVALID_VALUE should
+ * occur if index >= GL_MAX_VERTEX_ATTRIBS.
+ */
+
+#include "piglit-util-gl.h"
+
+PIGLIT_GL_TEST_CONFIG_BEGIN
+
+	config.supports_gl_core_version = 33;
+
+	config.window_visual = PIGLIT_GL_VISUAL_RGB | PIGLIT_GL_VISUAL_DOUBLE;
+
+PIGLIT_GL_TEST_CONFIG_END
+
+static int test = 0;
+
+#define CHECK_GL_INVALID_VALUE \
+	if (glGetError() != GL_INVALID_VALUE) return PIGLIT_FAIL; \
+	else printf("max-vertex-attrib test %d passed\n", ++test);
+
+enum piglit_result
+piglit_display(void)
+{
+	return PIGLIT_FAIL;
+}
+
+static GLboolean
+run_test(void)
+{
+	GLdouble doublev[] = { 1.0, 1.0, 1.0, 1.0 };
+	GLdouble quad[] = { -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0 };
+
+	int maxAttribCount;
+
+	glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &maxAttribCount);
+
+	glVertexAttribL1d(maxAttribCount, doublev[0]);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL2d(maxAttribCount, doublev[0], doublev[1]);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL3d(maxAttribCount, doublev[0], doublev[1], doublev[2]);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL4d(maxAttribCount, doublev[0], doublev[1], doublev[2],
+			 doublev[3]);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL1dv(maxAttribCount, doublev);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL2dv(maxAttribCount, doublev);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL3dv(maxAttribCount, doublev);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribL4dv(maxAttribCount, doublev);
+	CHECK_GL_INVALID_VALUE;
+
+	glVertexAttribLPointer(maxAttribCount, 2, GL_DOUBLE, 0, quad);
+	CHECK_GL_INVALID_VALUE;
+
+	glGetVertexAttribLdv(maxAttribCount, GL_CURRENT_VERTEX_ATTRIB, doublev);
+	CHECK_GL_INVALID_VALUE;
+
+        if (piglit_is_extension_supported("GL_EXT_direct_state_access")) {
+                uint vaobj;
+
+                glGenVertexArrays(1, &vaobj);
+                glBindVertexArray(vaobj);
+
+                glVertexArrayVertexAttribLOffsetEXT(vaobj, 0, maxAttribCount, 3,
+                                                    GL_DOUBLE, 0, 0);
+                glDeleteVertexArrays(1, &vaobj);
+                CHECK_GL_INVALID_VALUE;
+        }
+
+        return PIGLIT_PASS;
+}
+
+void piglit_init(int argc, char **argv)
+{
+	piglit_require_extension("GL_ARB_vertex_attrib_64bit");
+
+        piglit_report_result(run_test());
+}
diff --git a/tests/spec/arb_vertex_attrib_64bit/execution/overlapping-locations.c b/tests/spec/arb_vertex_attrib_64bit/execution/overlapping-locations.c
new file mode 100644
index 0000000..5828042
--- /dev/null
+++ b/tests/spec/arb_vertex_attrib_64bit/execution/overlapping-locations.c
@@ -0,0 +1,221 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/** @file overlapping-locations.c
+ *
+ * From OpenGL 3.2 spec ("Compatibility profile"), page 89:
+ *
+ *    "It is possible for an application to bind more than one attribute name to
+ *     the same location. This is referred to as aliasing. This will only work if
+ *     only one of the aliased attributes is active in the executable program, or
+ *     if no path through the shader consumes more than one attribute of a set
+ *     of attributes aliased to the same location. A link error can occur if the
+ *     linker determines that every path through the shader consumes multiple
+ *     aliased attributes, but implementations are not required to generate an
+ *     error in this case."
+ *
+ * This test verifies that aliasing can be used successfully for vertex
+ * attributes with 64-bit floating-point components.
+ *
+ * Based on GL_ARB_explicit_attrib_location's
+ * overlapping-locations-input-attribs.c
+ */
+
+#include "piglit-util-gl.h"
+
+PIGLIT_GL_TEST_CONFIG_BEGIN
+
+        config.supports_gl_compat_version = 21;
+        config.supports_gl_core_version = 31;
+
+        config.window_width = 128;
+        config.window_height = 128;
+        config.window_visual = PIGLIT_GL_VISUAL_DOUBLE | PIGLIT_GL_VISUAL_RGBA;
+
+PIGLIT_GL_TEST_CONFIG_END
+
+static bool locations_in_shader;
+static unsigned prog, vao, vertex_buf;
+
+void
+compile_shader(void)
+{
+	GLuint element_buf;
+	unsigned int indices[6] = { 0, 1, 2, 0, 2, 3 };
+	double vertex_data[4][11] = {
+		/* vertex     color0:green    color1:blue     color2:yellow */
+		{-1.0, -1.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 1.0, 0.0},
+		{-1.0,  1.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 1.0, 0.0},
+		{ 1.0,  1.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 1.0, 0.0},
+		{ 1.0, -1.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 1.0, 0.0}};
+
+	static const char *vert_template =
+		"#version 130\n"
+		"%s\n"
+		"out vec4 color;\n"
+		"uniform int x;\n"
+		"void main()\n"
+		"{\n"
+		"  gl_Position =vec4(vertex, 0, 1);\n"
+		"  switch(x) {\n"
+		"  case 0:\n"
+		"    color =vec4(color0, 1.0);\n"
+		"    break;\n"
+		"  case 1:\n"
+		"    color = vec4(color1, 1.0);\n"
+		"    break;\n"
+		"  case 2:\n"
+		"    color = vec4(color2, 1.0);\n"
+		"    break;\n"
+		"  default:\n"
+		"    color = vec4(1.0);;\n"
+		"  }\n"
+		"}\n";
+
+	static const char *frag =
+		"#version 130\n"
+		"in vec4 color;\n"
+		"out vec4 out_color;\n"
+		"void main()\n"
+		"{\n"
+		"    out_color = color;\n"
+		"}\n";
+
+	char *vert;
+	asprintf(&vert, vert_template, locations_in_shader ?
+		 "#extension GL_ARB_explicit_attrib_location : require\n"
+		 "#extension GL_ARB_gpu_shader_fp64 : require\n"
+		 "#extension GL_ARB_vertex_attrib_64bit : require\n"
+		 "layout (location = 0) in dvec2 vertex;\n"
+		 "layout (location = 1) in dvec3 color0;\n"
+		 "layout (location = 1) in dvec3 color1;\n"
+		 "layout (location = 1) in dvec3 color2;\n" :
+		 "#extension GL_ARB_gpu_shader_fp64 : require\n"
+		 "#extension GL_ARB_vertex_attrib_64bit : require\n"
+		 "in dvec2 vertex;\n"
+		 "in dvec3 color0;\n"
+		 "in dvec3 color1;\n"
+		 "in dvec3 color2;\n");
+
+	prog = piglit_build_simple_program_unlinked(vert, frag);
+	if (!locations_in_shader) {
+		glBindAttribLocation(prog, 0, "vertex");
+		glBindAttribLocation(prog, 1, "color0");
+		glBindAttribLocation(prog, 1, "color1");
+		glBindAttribLocation(prog, 1, "color2");
+	}
+	glLinkProgram(prog);
+
+	if (!piglit_link_check_status(prog))
+		piglit_report_result(PIGLIT_FAIL);
+
+	/* Set up vertex array object */
+	glGenVertexArrays(1, &vao);
+	glBindVertexArray(vao);
+
+	/* Set up vertex input buffer */
+	glGenBuffers(1, &vertex_buf);
+	glBindBuffer(GL_ARRAY_BUFFER, vertex_buf);
+	glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_data), vertex_data,
+		     GL_STREAM_DRAW);
+
+	glEnableVertexAttribArray(0);
+	glVertexAttribLPointer(0, 2, GL_DOUBLE, 11*sizeof(double),
+                               (void *) 0);
+	glEnableVertexAttribArray(1);
+
+	/* Set up element input buffer to tessellate a quad into
+	 * triangles
+	 */
+	glGenBuffers(1, &element_buf);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buf);
+	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices,
+		     GL_STATIC_DRAW);
+}
+
+static void
+print_usage_and_exit(char *prog_name)
+{
+	printf("Usage: %s <set_location>\n"
+	       "  where <set_location> is one of:\n"
+	       "    shader: set locations of input variables in shader program\n"
+	       "    api: set locations of input variables using api\n",
+	       prog_name);
+
+	piglit_report_result(PIGLIT_FAIL);
+}
+
+void
+piglit_init(int argc, char **argv)
+{
+	if (argc != 2)
+		print_usage_and_exit(argv[0]);
+
+	/* 1st arg: location */
+	if(strcmp(argv[1], "shader") != 0 &&
+	   strcmp(argv[1], "api") != 0)
+		print_usage_and_exit(argv[0]);
+
+	locations_in_shader = strcmp(argv[1], "shader") == 0;
+
+	if (locations_in_shader)
+		piglit_require_extension("GL_ARB_explicit_attrib_location");
+
+	piglit_require_extension("GL_ARB_vertex_array_object");
+	piglit_require_extension("GL_ARB_vertex_attrib_64bit");
+	piglit_require_extension("GL_ARB_gpu_shader_fp64");
+	piglit_require_GLSL_version(130);
+	compile_shader();
+	if (!piglit_check_gl_error(GL_NO_ERROR))
+		piglit_report_result(PIGLIT_FAIL);
+}
+
+enum piglit_result
+piglit_display()
+{
+	int i;
+	bool pass = true;
+	float expected[3][4] = {
+		{0.0, 1.0, 0.0, 1.0}, /* green */
+		{0.0, 0.0, 1.0, 1.0}, /* blue */
+		{1.0, 1.0, 0.0, 1.0}}; /* yellow */
+
+	glUseProgram(prog);
+
+	for(i = 0; i < 3; i++) {
+		glUniform1i(glGetUniformLocation(prog, "x"), i);
+
+		/* Setup VertexAttribPointer for location=1. There should be
+		 * only one active attribute pointer set to the shared location
+		 * '1' at a time.
+		 */
+		glVertexAttribLPointer(1, 3, GL_DOUBLE, 11*sizeof(double),
+                                       (void *) ((2 + 3*i) * sizeof(double)));
+
+		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void *) 0);
+		pass = piglit_probe_rect_rgba(0, 0, piglit_width, piglit_height,
+					      expected[i]) && pass;
+		piglit_present_results();
+	}
+	return pass ? PIGLIT_PASS : PIGLIT_FAIL;
+}
diff --git a/tests/spec/arb_vertex_attrib_64bit/execution/zero-vertex-attrib.c b/tests/spec/arb_vertex_attrib_64bit/execution/zero-vertex-attrib.c
new file mode 100644
index 0000000..7d61105
--- /dev/null
+++ b/tests/spec/arb_vertex_attrib_64bit/execution/zero-vertex-attrib.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright © 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+/**
+ * \file zero-vertex-attrib.c
+ *
+ * Test based on this paragraph of ARB_vertex_attrib_64bit spec:
+ * "  void GetVertexAttribLdv(uint index, enum pname, double *params);
+ * <skip>
+ *  The error INVALID_OPERATION is generated if index
+ *  is zero, as there is no current value for generic attribute zero."
+ *
+ * Also found on 4.1 core spec, section 6.1, page 338:
+ * "The error INVALID_OPERATION is generated if index is zero and
+ * pname is CURRENT_VERTEX_ATTRIB , since there is no current value
+ * for generic attribute zero."
+ *
+ */
+
+#include "piglit-util-gl.h"
+
+PIGLIT_GL_TEST_CONFIG_BEGIN
+
+	config.supports_gl_compat_version = 32;
+	config.supports_gl_core_version = 32;
+
+	config.window_visual = PIGLIT_GL_VISUAL_RGB | PIGLIT_GL_VISUAL_DOUBLE;
+
+PIGLIT_GL_TEST_CONFIG_END
+
+#define CHECK_GL_INVALID_OPERATION \
+	if (glGetError() != GL_INVALID_OPERATION) return PIGLIT_FAIL; \
+	else printf("max-vertex-attrib test %d passed\n", ++test);
+
+enum piglit_result
+piglit_display(void)
+{
+	return PIGLIT_FAIL;
+}
+
+static GLboolean
+run_test(void)
+{
+        enum piglit_result result = PIGLIT_PASS;
+        GLdouble doublev[] = { 1.0, 1.0, 1.0, 1.0 };
+
+        glGetVertexAttribLdv(0, GL_CURRENT_VERTEX_ATTRIB, doublev);
+        if (glGetError () != GL_INVALID_OPERATION) {
+                fprintf(stderr, "GL_INVALID_OPERATION expected when calling "
+                        "GetVertexAttribLdv with index 0 and pname GL_CURRENT_VERTEX_ATTRIB.\n");
+                result = PIGLIT_FAIL;
+        }
+
+        return result;
+}
+
+void piglit_init(int argc, char **argv)
+{
+        piglit_require_gl_version(20);
+
+        piglit_require_extension("GL_ARB_vertex_attrib_64bit");
+
+        piglit_report_result(run_test());
+}
